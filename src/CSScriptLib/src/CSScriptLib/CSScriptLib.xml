<?xml version="1.0"?>
<doc>
    <assembly>
        <name>CSScriptLib</name>
    </assembly>
    <members>
        <member name="T:CSScriptLib.CSharpParser">
            <summary>
            Very light parser for C# code. The main purpose of it is to be very fast and reliable.
            It only extracts code information relative to the CS-Script.
            </summary>
        </member>
        <member name="T:CSScriptLib.CSharpParser.CmdScriptInfo">
            <summary>
            Class to hold the script information on what pre- or post-execution script needs to be executed.
            pre- and post-script CS-Script command format:
            //css_prescript file([arg0][, arg1]..[,arg2])[,ignore];
            //file - script file (extension is optional)
            //arg0..N - script string arguments;
            If $this is specified as arg0..N it will be replaced with the parent script full name at execution time.
            </summary>
        </member>
        <member name="M:CSScriptLib.CSharpParser.CmdScriptInfo.#ctor(System.String,System.Boolean,System.String)">
            <summary>
            Creates an instance of CmdScriptInfo.
            </summary>
            <param name="statement">CS-Script pre- or post-script directive</param>
            <param name="preScript">If set to true the 'statement' is a pre-script otherwise it is a post-script.</param>
            <param name="parentScript">The file name of the main script.</param>
        </member>
        <member name="F:CSScriptLib.CSharpParser.CmdScriptInfo.args">
            <summary>
            Script file and it's arguments.
            </summary>
        </member>
        <member name="F:CSScriptLib.CSharpParser.CmdScriptInfo.preScript">
            <summary>
            If set to 'true' the CmdScriptInfo describes the pre-script, otherwise it is for the post-script.
            </summary>
        </member>
        <member name="F:CSScriptLib.CSharpParser.CmdScriptInfo.abortOnError">
            <summary>
            If set to 'true' parent script will be aborted on pre/post-script error, otherwise the error will be ignored.
            </summary>
        </member>
        <member name="T:CSScriptLib.CSharpParser.InitInfo">
            <summary>
            Class to hold the script initialization information.
            </summary>
        </member>
        <member name="F:CSScriptLib.CSharpParser.InitInfo.CoInitializeSecurity">
            <summary>
            The boolean flag indicating if CoInitializeSecurity (with default parameters) should be called at the start of the script execution.
            </summary>
        </member>
        <member name="F:CSScriptLib.CSharpParser.InitInfo.RpcImpLevel">
            <summary>
            The RpcImpLevel of CoInitializeSecurity arguments
            </summary>
        </member>
        <member name="F:CSScriptLib.CSharpParser.InitInfo.EoAuthnCap">
            <summary>
            The EoAuthnCap of CoInitializeSecurity arguments
            </summary>
        </member>
        <member name="M:CSScriptLib.CSharpParser.InitInfo.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:CSScriptLib.CSharpParser.InitInfo" /> class.
            </summary>
            <param name="statement">The original argument statement of the <c>//css_init</c> directive.</param>
        </member>
        <member name="T:CSScriptLib.CSharpParser.ImportInfo">
            <summary>
            Class to hold the script importing information, which actually controls how script is imported.
            </summary>
        </member>
        <member name="M:CSScriptLib.CSharpParser.ImportInfo.#ctor(System.String,System.String)">
            <summary>
            Creates an instance of ImportInfo.
            </summary>
            <param name="statement">CS-Script import directive (//css_import...) string.</param>
            <param name="parentScript">name of the parent (primary) script file.</param>
        </member>
        <member name="F:CSScriptLib.CSharpParser.ImportInfo.file">
            <summary>
            The file to be imported.
            </summary>
        </member>
        <member name="F:CSScriptLib.CSharpParser.ImportInfo.renaming">
            <summary>
            Renaming instructions (old_name vs. new_name)
            </summary>
        </member>
        <member name="F:CSScriptLib.CSharpParser.ImportInfo.preserveMain">
            <summary>
            If set to 'true' "static...Main" in the imported script is not renamed.
            </summary>
        </member>
        <member name="M:CSScriptLib.CSharpParser.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:CSScriptLib.CSharpParser" /> class.
            </summary>
        </member>
        <member name="M:CSScriptLib.CSharpParser.#ctor(System.String)">
            <summary>
            Creates an instance of CSharpParser.
            </summary>
            <param name="code">C# code string</param>
        </member>
        <member name="M:CSScriptLib.CSharpParser.#ctor(System.String,System.Boolean)">
            <summary>
            Creates an instance of CSharpParser.
            </summary>
            <param name="script">C# script (code or file).</param>
            <param name="isFile">If set to 'true' the script is a file, otherwise it is a C# code.</param>
        </member>
        <member name="M:CSScriptLib.CSharpParser.#ctor(System.String,System.Boolean,System.String[])">
            <summary>
            Creates an instance of CSharpParser.
            </summary>
            <param name="script">C# script (code or file).</param>
            <param name="isFile">If set to 'true' the script is a file, otherwise it is a C# code.</param>
            <param name="directivesToSearch">Additional C# script directives to search. The search result is stored in CSharpParser.CustomDirectives.</param>
        </member>
        <member name="M:CSScriptLib.CSharpParser.#ctor(System.String,System.Boolean,System.String[],System.String[])">
            <summary>
            Creates an instance of CSharpParser.
            </summary>
            <param name="script">C# script (code or file).</param>
            <param name="isFile">If set to 'true' the script is a file, otherwise it is a C# code.</param>
            <param name="directivesToSearch">Additional C# script directives to search. The search result is stored in CSharpParser.CustomDirectives.</param>
            <param name="probingDirs">Search directories for resolving wild card paths in //css_inc and //css_imp</param>
        </member>
        <member name="F:CSScriptLib.CSharpParser.CustomDirectives">
            <summary>
            The result of search for additional C# script directives to search (directive vs. value).
            </summary>
        </member>
        <member name="F:CSScriptLib.CSharpParser.SupressCodeAnalysis">
            <summary>
            Global flag to forcefuly supress any C# code analysys. This flag efectively disables
            all CS-Script assembly and script probing and most likely some other functionality.
            <para>You may ever want to suppress code analysis only for profiling purposes or during performance tuning.</para>
            </summary>
        </member>
        <member name="M:CSScriptLib.CSharpParser.Init(System.String,System.String,System.String[],System.String[])">
            <summary>
            Parses the C# code.
            </summary>
            <param name="code">C# script (code or file).</param>
            <param name="file">If set to 'true' the script is a file, otherwise it is a C# code.</param>
            <param name="directivesToSearch">Additional C# script directives to search. The search result is stored in CSharpParser.CustomDirectives.</param>
            <param name="probingDirs">Search directories for resolving wild card paths in //css_inc and //css_imp</param>
        </member>
        <member name="M:CSScriptLib.CSharpParser.DoRenaming(System.String[][],System.Boolean)">
            <summary>
            Renames namespaces according renaming instructions.
            </summary>
            <param name="renamingMap">Renaming instructions (old_name vs. new_name).</param>
            <param name="preserveMain">/// If set to 'true' "static...Main" in the imported script is not renamed.</param>
        </member>
        <member name="P:CSScriptLib.CSharpParser.Args">
            <summary>
            Embedded script arguments. The both script and engine arguments are allowed except "/noconfig" engine command line switch.
            </summary>
        </member>
        <member name="P:CSScriptLib.CSharpParser.CompilerOptions">
            <summary>
            Embedded compiler options.
            </summary>
        </member>
        <member name="P:CSScriptLib.CSharpParser.HostOptions">
            <summary>
            Embedded compiler options.
            </summary>
        </member>
        <member name="P:CSScriptLib.CSharpParser.Precompilers">
            <summary>
            Precompilers.
            </summary>
        </member>
        <member name="P:CSScriptLib.CSharpParser.References">
            <summary>
            References to the external assemblies and namespaces.
            </summary>
        </member>
        <member name="P:CSScriptLib.CSharpParser.RefAssemblies">
            <summary>
            References to the external assemblies.
            </summary>
        </member>
        <member name="P:CSScriptLib.CSharpParser.IgnoreNamespaces">
            <summary>
            Names of namespaces to be ignored by namespace-to-assembly resolver.
            </summary>
        </member>
        <member name="P:CSScriptLib.CSharpParser.ExtraSearchDirs">
            <summary>
            Additional search directories (for script and assembly probing).
            </summary>
        </member>
        <member name="P:CSScriptLib.CSharpParser.ResFiles">
            <summary>
            References to the resource files.
            </summary>
        </member>
        <member name="P:CSScriptLib.CSharpParser.RefNamespaces">
            <summary>
            References to the namespaces.
            </summary>
        </member>
        <member name="P:CSScriptLib.CSharpParser.NuGets">
            <summary>
            References to the NuGet packages.
            </summary>
        </member>
        <member name="P:CSScriptLib.CSharpParser.Imports">
            <summary>
            C# scripts to be imported.
            </summary>
        </member>
        <member name="P:CSScriptLib.CSharpParser.CmdScripts">
            <summary>
            Pre- and post-execution scripts.
            </summary>
        </member>
        <member name="P:CSScriptLib.CSharpParser.Inits">
            <summary>
            Script initialization directives.
            </summary>
        </member>
        <member name="P:CSScriptLib.CSharpParser.Code">
            <summary>
            Script C# raw code.
            </summary>
        </member>
        <member name="P:CSScriptLib.CSharpParser.ModifiedCode">
            <summary>
            Script C# code after namespace renaming.
            </summary>
        </member>
        <member name="F:CSScriptLib.CSharpParser.OpenEndDirectiveSyntax">
            <summary>
            Enables omitting closing character (";") for CS-Script directives (e.g. "//css_ref System.Xml.dll" instead of "//css_ref System.Xml.dll;").
            </summary>
        </member>
        <member name="M:CSScriptLib.CSharpParser.EscapeDirectiveDelimiters(System.String)">
            <summary>
            Escapes the CS-Script directive (e.g. //css_*) delimiters.
            <para>All //css_* directives should escape any internal CS-Script delimiters by doubling the delimiter character.
            For example //css_include for 'script(today).cs' should escape brackets as they are the directive delimiters.
            The correct syntax would be as follows '//css_include script((today)).cs;'</para>
            <remarks>The delimiters characters are ';,(){}'.
            <para>However you should check <see cref="F:CSScriptLib.CSharpParser.DirectiveDelimiters" /> for the accurate list of all delimiters.
            </para>
            </remarks>
            </summary>
            <param name="text">The text to be processed.</param>
            <returns></returns>
        </member>
        <member name="M:CSScriptLib.CSharpParser.UserToInternalEscaping(System.String)">
             <summary>
             Replaces the user escaped delimiters with internal escaping.
             <p> "{char}{char}" -> "\u{((int)c).ToString("x4")}"</p>
             <p> "((" -> "\u0028"</p>
             </summary>
             <param name="text">The text.</param>
             <returns></returns>
        </member>
        <member name="M:CSScriptLib.CSharpParser.UnescapeDirectiveDelimiters(System.String)">
            <summary>
            Unescapes the CS-Script directive (e.g. //css_*) delimiters.
            <para>All //css_* directives should escape any internal CS-Script delimiters by doubling the delimiter character.
            For example //css_include for 'script(today).cs' should escape brackets as they are the directive delimiters.
            The correct syntax would be as follows '//css_include script((today)).cs;'</para>
            <remarks>The delimiters characters are ';,(){}'.
            <para>However you should check <see cref="F:CSScriptLib.CSharpParser.DirectiveDelimiters" /> for the accurate list of all delimiters.
            </para>
            </remarks>
            </summary>
            <param name="text">The text to be processed.</param>
            <returns></returns>
        </member>
        <member name="F:CSScriptLib.CSharpParser.DirectiveDelimiters">
            <summary>
            The //css_* directive delimiters.
            <remarks>All //css_* directives should escape any internal CS-Script delimiters by doubling the delimiter character.
            For example //css_include for 'script(today).cs' should escape brackets as they are the directive delimiters.
            The correct syntax would be as follows '//css_include script((today)).cs;'
            </remarks>
            </summary>
        </member>
        <member name="T:CSScriptLib.Settings">
            <summary>
            Settings is an class that holds CS-Script application settings.
            </summary>
        </member>
        <member name="P:CSScriptLib.Settings.SearchDirs">
            <summary>
            List of directories to be used to search (probing) for referenced assemblies and script files.
            This setting is similar to the system environment variable PATH.
            </summary>
        </member>
        <member name="M:CSScriptLib.Settings.ClearSearchDirs">
            <summary>
            Clears the search directories.
            </summary>
            <returns></returns>
        </member>
        <member name="M:CSScriptLib.Settings.AddSearchDir(System.String)">
            <summary>
            Adds the search directories aggregated from the unique locations of all assemblies referenced by the host application.
            </summary>
            <param name="dir">The dir.</param>
            <returns></returns>
        </member>
        <member name="M:CSScriptLib.Settings.AddSearchDirsFromHost">
            <summary>
            Adds the search dirs from host.
            </summary>
            <returns></returns>
        </member>
        <member name="T:CSScriptLib.CSScript">
            <summary>
            Class which is implements CS-Script class library interface.
            </summary>
        </member>
        <member name="M:CSScriptLib.CSScript.GetScriptTempDir">
            <summary>
            Returns the name of the temporary folder in the CSSCRIPT subfolder of Path.GetTempPath().
            <para>Under certain circumstances it may be desirable to the use the alternative location for the CS-Script temporary files.
            In such cases use SetScriptTempDir() to set the alternative location.
            </para>
            </summary>
            <returns>Temporary directory name.</returns>
        </member>
        <member name="M:CSScriptLib.CSScript.GetScriptTempFile">
            <summary>
            Returns the name of the temporary file in the CSSCRIPT subfolder of Path.GetTempPath().
            </summary>
            <returns>Temporary file name.</returns>
        </member>
        <member name="F:CSScriptLib.CSScript.GlobalSettings">
            <summary>
            Settings object containing runtime settings, which controls script compilation/execution.
            This is Settings class essentially is a deserialized content of the CS-Script configuration file (css_config.xml).
            </summary>
        </member>
        <member name="P:CSScriptLib.CSScript.RoslynEvaluator">
            <summary>
            Global instance of <see cref="T:CSScriptLib.RoslynEvaluator" />. This object is to be used for
            dynamic loading of the  C# code by using Roslyn "compiler as service".
            <para>If you need to use multiple instances of th evaluator then you will need to call
            <see cref="T:CSScriptLib.IEvaluator" />.Clone().
            </para>
            </summary>
            <value> The <see cref="T:CSScriptLib.RoslynEvaluator" /> instance.</value>
        </member>
        <member name="P:CSScriptLib.CSScript.EvaluatorConfig">
            <summary>
            Gets the CSScript.<see cref="T:CSScriptLib.EvaluatorConfig" />, which controls the way code evaluation is conducted at runtime.
            </summary>
            <value>The evaluator CSScript.<see cref="T:CSScriptLib.EvaluatorConfig" />.</value>
        </member>
        <member name="P:CSScriptLib.CSScript.Evaluator">
             <summary>
             Global instance of the generic <see cref="T:CSScriptLib.IEvaluator" />. This object is to be used for
             dynamic loading of the  C# code by "compiler as service" based on the
             <see cref="P:CSScriptLib.CSScript.EvaluatorConfig.Engine" /> value.
             <para>Generic <see cref="T:CSScriptLib.IEvaluator" /> interface provides a convenient way of accessing
             compilers without 'committing' to a specific compiler technology (e.g. Mono, Roslyn, CodeDOM). This may be
             required during troubleshooting or performance tuning.</para>
             <para>Switching between compilers can be done via global
             CSScript.<see cref="P:CSScriptLib.CSScript.EvaluatorConfig.Engine" />.</para>
             <remarks>
             By default CSScript.<see cref="P:CSScriptLib.CSScript.Evaluator" /> always returns a new instance of
             <see cref="T:CSScriptLib.IEvaluator" />. If this behavior is undesired change the evaluator access
             policy by setting <see cref="P:CSScriptLib.CSScript.EvaluatorConfig" />.Access value.
             </remarks>
             </summary>
             <value>The <see cref="T:CSScriptLib.IEvaluator" /> instance.</value>
             <example>
            <code>
             if(testingWithMono)
                 CSScript.EvaluatorConfig.Engine = EvaluatorEngine.Mono;
             else
                 CSScript.EvaluatorConfig.Engine = EvaluatorEngine.Roslyn;

             var sub = CSScript.Evaluator
                               .LoadDelegate&lt;Func&lt;int, int, int&gt;&gt;(
                                           @"int Sub(int a, int b) {
                                                 return a - b;
                                             }");
             </code>
             </example>
        </member>
        <member name="T:CSScriptLib.CompileInfo">
            <summary>
            The information about the location of the compiler output - assembly and pdb file.
            </summary>
        </member>
        <member name="P:CSScriptLib.CompileInfo.AssemblyFile">
            <summary>
            The assembly file path. If not specified it will be composed as "&lt;RootClass&gt;.dll".
            </summary>
        </member>
        <member name="P:CSScriptLib.CompileInfo.PdbFile">
            <summary>
            The PDB file path.
            <para>Even if the this value is specified the file will not be generated unless
            <see cref="P:CSScriptLib.CSScript.EvaluatorConfig" />.DebugBuild is set to <c>true</c>.
            </para>
            </summary>
        </member>
        <member name="P:CSScriptLib.CompileInfo.RootClass">
            <summary>
            Gets or sets the root class name.
            <para>This setting is required as Roslyn cannot produce compiled scripts with the user script class defined as
            a top level class. Thus all user defined classes are in fact nested classes with the root class
            named by Roslyn as "Submission#0". This leads to the complications when user wants to reference script class in
            another script. Specifically because C# treats "Submission#0" as an illegal class name. </para>
            <para>C# helps the situation by allowing user specified root name <see cref="P:CSScriptLib.CompileInfo.RootClass" />,
            which is by default is "css_root".
            </para>
            </summary>
            <value>
            The root class name.
            </value>
        </member>
        <member name="P:CSScriptLib.CompileInfo.PreferLoadingFromFile">
            <summary>
            Gets or sets a value indicating whether to prefer loading compiled script from the assembly file when
            it is available.
            </summary>
            <value>
              <c>true</c> if [prefer loading from file]; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="T:CSScriptLib.CompilerException">
            <summary>
            The exception that is thrown when a the script compiler error occurs.
            </summary>
        </member>
        <member name="M:CSScriptLib.CompilerException.#ctor">
            <summary>
            Initialises a new instance of the <see cref="T:CSScriptLib.CompilerException" /> class.
            </summary>
        </member>
        <member name="M:CSScriptLib.CompilerException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initialises a new instance of the <see cref="T:CSScriptLib.CompilerException" /> class.
            </summary>
            <param name="info">The object that holds the serialized object data.</param>
            <param name="context">The contextual information about the source or destination.</param>
        </member>
        <member name="M:CSScriptLib.CompilerException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:CSScriptLib.CompilerException" /> class.
            </summary>
            <param name="message">The message.</param>
        </member>
        <member name="T:CSScriptLib.RoslynEvaluator">
            <summary>
            A wrapper class that encapsulates the functionality of the Roslyn  evaluator (<see cref="N:Microsoft.CodeAnalysis.CSharp.Scripting" />).
            </summary>
        </member>
        <member name="P:CSScriptLib.RoslynEvaluator.DebugBuild">
            <summary>
            Gets or sets a value indicating whether to compile script with debug symbols.
            <para>Note, setting <c>DebugBuild</c> will only affect the current instance of Evaluator.
            If you want to emit debug symbols for all instances of Evaluator then use
            <see cref="P:CSScriptLib.CSScript.EvaluatorConfig" />.DebugBuild.
            </para>
            </summary>
            <value><c>true</c> if 'debug build'; otherwise, <c>false</c>.</value>
        </member>
        <member name="M:CSScriptLib.RoslynEvaluator.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:CSScriptLib.RoslynEvaluator" /> class.
            </summary>
        </member>
        <member name="M:CSScriptLib.RoslynEvaluator.Clone(System.Boolean)">
            <summary>
            Clones itself as <see cref="T:CSScriptLib.IEvaluator" />.
            <para>
            This method returns a freshly initialized copy of the <see cref="T:CSScriptLib.IEvaluator" />.
            The cloning 'depth' can be controlled by the <paramref name="copyRefAssemblies" />.
            </para>
            <para>
            This method is a convenient technique when multiple <see cref="T:CSScriptLib.IEvaluator" /> instances
            are required (e.g. for concurrent script evaluation).
            </para>
            </summary>
            <param name="copyRefAssemblies">if set to <c>true</c> all referenced assemblies from the parent <see cref="T:CSScriptLib.IEvaluator" />
            will be referenced in the cloned copy.</param>
            <returns>The freshly initialized instance of the <see cref="T:CSScriptLib.IEvaluator" />.</returns>
        </member>
        <member name="P:CSScriptLib.RoslynEvaluator.CompilerSettings">
            <summary>
            Gets or sets the compiler settings.
            </summary>
            <value>The compiler settings.</value>
        </member>
        <member name="M:CSScriptLib.RoslynEvaluator.LoadCompilers">
            <summary>
            Loads the assemblies implementing Roslyn compilers.
            <para>Roslyn compilers are extremely heavy and loading the compiler assemblies for with the first
            evaluation call can take a significant time to complete (in some cases up to 4 seconds) while the consequent
            calls are very fast.
            </para>
            <para>
            You may want to call this method to pre-load the compiler assembly your script evaluation performance.
            </para>
            </summary>
        </member>
        <member name="M:CSScriptLib.RoslynEvaluator.CompileCode(System.String)">
             <summary>
             Evaluates (compiles) C# code (script). The C# code is a typical C# code containing a single or multiple class definition(s).
             </summary>
             <example>
            <code>
             Assembly asm = CSScript.RoslynEvaluator
                                    .CompileCode(@"using System;
                                                   public class Script
                                                   {
                                                       public int Sum(int a, int b)
                                                       {
                                                           return a+b;
                                                       }
                                                   }");

             dynamic script =  asm.CreateObject("*");
             var result = script.Sum(7, 3);
             </code>
             </example>
             <param name="scriptText">The C# script text.</param>
             <returns>The compiled assembly.</returns>
        </member>
        <member name="M:CSScriptLib.RoslynEvaluator.CompileCode(System.String,CSScriptLib.CompileInfo)">
             <summary>
             Evaluates (compiles) C# code (script). The C# code is a typical C# code containing a single or multiple class definition(s).
             <para>The method is identical to <see cref="M:CSScriptLib.RoslynEvaluator.CompileCode(System.String)" /> except that it allows specifying
             the destination assembly file.</para>
             </summary>
             <example>
             <code>
             var info = new CompileInfo
             {
                 AssemblyFile = @"E:\temp\asm.dll"
             };

             Assembly asm = CSScript.Evaluator
                                    .Cast&lt;RoslynEvaluator&gt;()
                                    .CompileCode(@"using System;
                                                   public class Script
                                                   {
                                                       public int Sum(int a, int b)
                                                       {
                                                           return a+b;
                                                       }
                                                   }",
                                                   info);

             dynamic script =  asm.CreateObject("*");
             var result = script.Sum(7, 3);
             </code>
             </example>
             <param name="scriptText">The C# script text.</param>
             <param name="info"></param>
             <returns>The compiled assembly.</returns>
        </member>
        <member name="M:CSScriptLib.RoslynEvaluator.CompileAssemblyFromFile(System.String,System.String)">
            <summary>
            Compiles C# file (script) into assembly file. The C# contains typical C# code containing a single or multiple class definition(s).
            </summary>
            <param name="scriptFile">The C# script file.</param>
            <param name="outputFile">The path to the assembly file to be compiled.</param>
            <returns>
            The compiled assembly file path.
            </returns>
            <example>
              <code>
            string asmFile = CSScript.Evaluator
                                     .CompileAssemblyFromFile("MyScript.cs", "MyScript.dll");
            </code>
            </example>
        </member>
        <member name="M:CSScriptLib.RoslynEvaluator.CompileAssemblyFromCode(System.String,System.String)">
             <summary>
             Compiles C# code (script) into assembly file. The C# code is a typical C# code containing a single or multiple class definition(s).
             </summary>
             <example>
            <code>
             string asmFile = CSScript.Evaluator
                                      .CompileAssemblyFromCode(
                                             @"using System;
                                               public class Script
                                               {
                                                   public int Sum(int a, int b)
                                                   {
                                                       return a+b;
                                                   }
                                               }",
                                               "MyScript.dll");
             </code>
             </example>
             <param name="scriptText">The C# script text.</param>
             <param name="outputFile">The path to the assembly file to be compiled.</param>
             <returns>The compiled assembly file path.</returns>
        </member>
        <member name="M:CSScriptLib.RoslynEvaluator.Check(System.String)">
             <summary>
             Compiles the specified script text without loading it into the AppDomain or
             writing to the file system.
             </summary>
             <example>
            <code>
             try
             {
                 CSScript.Evaluator
                         .Check(@"using System;
                                  public class Script
                                  {
                                      public int Sum(int a, int b)
                                      {
                                          error
                                          return a+b;
                                      }
                                  }");
             }
             catch (Exception e)
             {
                 Console.WriteLine("Compile error: " + e.Message);
             }
             </code>
             </example>
             <param name="scriptText">The script text.</param>
             <returns></returns>
        </member>
        <member name="M:CSScriptLib.RoslynEvaluator.CompileMethod(System.String)">
             <summary>
             Wraps C# code fragment into auto-generated class (type name <c>DynamicClass</c>) and evaluates it.
             <para>
             This method is a logical equivalent of <see cref="M:CSScriptLib.IEvaluator.CompileCode(System.String,CSScriptLib.CompileInfo)" /> but is allows you to define
             your script class by specifying class method instead of whole class declaration.</para>
             </summary>
             <example>
            <code>
             dynamic script = CSScript.RoslynEvaluator
                                      .CompileMethod(@"int Sum(int a, int b)
                                                       {
                                                           return a+b;
                                                       }")
                                      .CreateObject("*");

             var result = script.Sum(7, 3);
             </code>
             </example>
             <param name="code">The C# code.</param>
             <returns>The compiled assembly.</returns>
        </member>
        <member name="M:CSScriptLib.RoslynEvaluator.CreateDelegate(System.String)">
             <summary>
             Wraps C# code fragment into auto-generated class (type name <c>DynamicClass</c>), evaluates it and loads the class to the current AppDomain.
             <para>Returns non-typed <see cref="T:CSScriptLib.MethodDelegate" /> for class-less style of invoking.</para>
             </summary>
             <example>
             <code>
             var log = CSScript.RoslynEvaluator
                               .CreateDelegate(@"void Log(string message)
                                                 {
                                                     Console.WriteLine(message);
                                                 }");

             log("Test message");
             </code>
             </example>
             <param name="code">The C# code.</param>
             <returns> The instance of a non-typed <see cref="T:CSScriptLib.MethodDelegate" /></returns>
        </member>
        <member name="M:CSScriptLib.RoslynEvaluator.CreateDelegate``1(System.String)">
             <summary>
             Wraps C# code fragment into auto-generated class (type name <c>DynamicClass</c>), evaluates it and loads the class to the current AppDomain.
             <para>Returns typed <see cref="T:CSScriptLib.MethodDelegate`1" /> for class-less style of invoking.</para>
             </summary>
             <typeparam name="T">The delegate return type.</typeparam>
             <example>
             <code>
             var product = CSScript.RoslynEvaluator
                                   .CreateDelegate&lt;int&gt;(@"int Product(int a, int b)
                                                         {
                                                             return a * b;
                                                         }");

             int result = product(3, 2);
             </code>
             </example>
             <param name="code">The C# code.</param>
             <returns> The instance of a typed <see cref="T:CSScriptLib.MethodDelegate`1" /></returns>
        </member>
        <member name="M:CSScriptLib.RoslynEvaluator.GetReferencedAssemblies">
            <summary>
            Returns set of referenced assemblies.
            <para>
            Notre: the set of assemblies is cleared on Reset.
            </para>
            </summary>
            <returns></returns>
        </member>
        <member name="M:CSScriptLib.RoslynEvaluator.GetReferencedAssemblies(System.String,System.String[])">
            <summary>
            Analyses the script code and returns set of locations for the assemblies referenced from the code with CS-Script directives (//css_ref).
            </summary>
            <param name="code">The script code.</param>
            <param name="searchDirs">The assembly search/probing directories.</param>
            <returns>Array of the referenced assemblies</returns>
        </member>
        <member name="M:CSScriptLib.RoslynEvaluator.LoadCode(System.String,System.Object[])">
             <summary>
             Evaluates and loads C# code to the current AppDomain. Returns instance of the first class defined in the code.
             </summary>
             <example>The following is the simple example of the LoadCode usage:
            <code>
             dynamic script = CSScript.RoslynEvaluator
                                      .LoadCode(@"using System;
                                                  public class Script
                                                  {
                                                      public int Sum(int a, int b)
                                                      {
                                                          return a+b;
                                                      }
                                                  }");
             int result = script.Sum(1, 2);
             </code>
             </example>
             <param name="scriptText">The C# script text.</param>
             <param name="args">The non default constructor arguments.</param>
             <returns>Instance of the class defined in the script.</returns>
        </member>
        <member name="M:CSScriptLib.RoslynEvaluator.LoadCode``1(System.String,System.Object[])">
            <summary>
            Evaluates and loads C# code to the current AppDomain. Returns instance of the first class defined in the code.
            </summary>
            <typeparam name="T">The type of the script class instance should be type casted to.</typeparam>
            <param name="scriptText">The C# script text.</param>
            <param name="args">The non default type <c>T</c> constructor arguments.</param>
            <returns>
            Aligned to the <c>T</c> interface instance of the class defined in the script.
            </returns>
            <example>The following is the simple example of the interface alignment:
            <code>
            public interface ICalc
            {
                int Sum(int a, int b);
            }
            ....
            ICalc calc = CSScript.Evaluator
                                 .LoadCode&lt;ICalc&gt;(@"using System;
                                                    public class Script
                                                    {
                                                        public int Sum(int a, int b)
                                                        {
                                                            return a+b;
                                                        }
                                                    }");
            int result = calc.Sum(1, 2);
            </code></example>
        </member>
        <member name="M:CSScriptLib.RoslynEvaluator.LoadDelegate``1(System.String)">
             <summary>
             Wraps C# code fragment into auto-generated class (type name <c>DynamicClass</c>), evaluates it and loads
             the class to the current AppDomain.
             <para>Returns instance of <c>T</c> delegate for the first method in the auto-generated class.</para>
             </summary>
              <example>
             <code>
             var Product = CSScript.Evaluator
                                   .LoadDelegate&lt;Func&lt;int, int, int&gt;&gt;(
                                               @"int Product(int a, int b)
                                                 {
                                                     return a * b;
                                                 }");

             int result = Product(3, 2);
             </code>
             </example>
             <param name="code">The C# code.</param>
             <returns>Instance of <c>T</c> delegate.</returns>
        </member>
        <member name="M:CSScriptLib.RoslynEvaluator.LoadFile(System.String,System.Object[])">
             <summary>
             Evaluates and loads C# code from the specified file to the current AppDomain. Returns instance of the first
             class defined in the script file.
             </summary>
             <example>The following is the simple example of the interface alignment:
            <code>
             dynamic script = CSScript.RoslynEvaluator
                                      .LoadFile("calc.cs");

             int result = script.Sum(1, 2);
             </code>
             </example>/// <param name="scriptFile">The C# script file.</param>
             <param name="args">Optional non-default constructor arguments.</param>
             <returns>Instance of the class defined in the script file.</returns>
        </member>
        <member name="M:CSScriptLib.RoslynEvaluator.LoadFile``1(System.String,System.Object[])">
             <summary>
             Evaluates and loads C# code from the specified file to the current AppDomain. Returns instance of the first
             class defined in the script file.
             After initializing the class instance it is aligned to the interface specified by the parameter <c>T</c>.
             <para><c>Note:</c> the script class does not have to inherit from the <c>T</c> parameter as the proxy type
             will be generated anyway.</para>
             </summary>
             <example>The following is the simple example of the interface alignment:
            <code>
             public interface ICalc
             {
                 int Sum(int a, int b);
             }
             ....
             ICalc calc = CSScript.Evaluator
                                  .LoadFile&lt;ICalc&gt;("calc.cs");

             int result = calc.Sum(1, 2);
             </code>
             </example>
             <typeparam name="T">The type of the interface type the script class instance should be aligned to.</typeparam>
             <param name="scriptFile">The C# script text.</param>
             <param name="args">Optional non-default constructor arguments.</param>
             <returns>Aligned to the <c>T</c> interface instance of the class defined in the script file.</returns>
        </member>
        <member name="M:CSScriptLib.RoslynEvaluator.LoadMethod(System.String)">
             <summary>
             Wraps C# code fragment into auto-generated class (type name <c>DynamicClass</c>), evaluates it and loads
             the class to the current AppDomain.
             </summary>
             <example>The following is the simple example of the LoadMethod usage:
             <code>
             dynamic script = CSScript.RoslynEvaluator
                                      .LoadMethod(@"int Product(int a, int b)
                                                    {
                                                        return a * b;
                                                    }");

             int result = script.Product(3, 2);
             </code>
             </example>
             <param name="code">The C# script text.</param>
             <returns>Instance of the first class defined in the script.</returns>
        </member>
        <member name="M:CSScriptLib.RoslynEvaluator.LoadMethod``1(System.String)">
            <summary>
            Wraps C# code fragment into auto-generated class (type name <c>DynamicClass</c>), evaluates it and loads
            the class to the current AppDomain.
            <para>
            After initializing the class instance it is aligned to the interface specified by the parameter <c>T</c>.
            </para>
            </summary>
            <example>The following is the simple example of the interface alignment:
            <code>
            public interface ICalc
            {
                int Sum(int a, int b);
                int Div(int a, int b);
            }
            ....
            ICalc script = CSScript.RoslynEvaluator
                                   .LoadMethod&lt;ICalc&gt;(@"public int Sum(int a, int b)
                                                        {
                                                            return a + b;
                                                        }
                                                        public int Div(int a, int b)
                                                        {
                                                            return a/b;
                                                        }");
            int result = script.Div(15, 3);
            </code>
            </example>
            <typeparam name="T">The type of the interface type the script class instance should be aligned to.</typeparam>
            <param name="code">The C# script text.</param>
            <returns>Aligned to the <c>T</c> interface instance of the auto-generated class defined in the script.</returns>
        </member>
        <member name="P:CSScriptLib.RoslynEvaluator.DisableReferencingFromCode">
            <summary>
            Gets or sets the flag indicating if the script code should be analyzed and the assemblies
            that the script depend on (via '//css_...' and 'using ...' directives) should be referenced.
            </summary>
            <value></value>
        </member>
        <member name="M:CSScriptLib.RoslynEvaluator.ReferenceAssembliesFromCode(System.String,System.String[])">
            <summary>
            References the assemblies from the script code.
            <para>The method analyses and tries to resolve CS-Script directives (e.g. '//css_ref') and 'used' namespaces based on the
            optional search directories.</para>
            </summary>
            <param name="code">The script code.</param>
            <param name="searchDirs">The assembly search/probing directories.</param>
            <returns>The instance of the <see cref="T:CSScriptLib.IEvaluator" /> to allow  fluent interface.</returns>
        </member>
        <member name="M:CSScriptLib.RoslynEvaluator.ReferenceAssembly(System.String)">
            <summary>
            References the given assembly by the assembly path.
            <para>It is safe to call this method multiple times for the same assembly. If the assembly already referenced it will not
            be referenced again.</para>
            </summary>
            <param name="assembly">The path to the assembly file.</param>
            <returns>The instance of the <see cref="T:CSScriptLib.IEvaluator" /> to allow  fluent interface.</returns>
        </member>
        <member name="M:CSScriptLib.RoslynEvaluator.ReferenceAssembly(System.Reflection.Assembly)">
            <summary>
            References the given assembly.
            <para>It is safe to call this method multiple times
            for the same assembly. If the assembly already referenced it will not
            be referenced again.
            </para>
            </summary>
            <param name="assembly">The assembly instance.</param>
            <returns>The instance of the <see cref="T:CSScriptLib.IEvaluator" /> to allow  fluent interface.</returns>
        </member>
        <member name="M:CSScriptLib.RoslynEvaluator.ReferenceAssemblyByName(System.String)">
            <summary>
            References the name of the assembly by its partial name.
            <para>Note that the referenced assembly will be loaded into the host AppDomain in order to resolve assembly partial name.</para>
            <para>It is an equivalent of <c>Evaluator.ReferenceAssembly(Assembly.Load(assemblyPartialName))</c></para>
            </summary>
            <param name="assemblyName">Name of the assembly.</param>
            <returns>The instance of the <see cref="T:CSScriptLib.IEvaluator" /> to allow  fluent interface.</returns>
        </member>
        <member name="M:CSScriptLib.RoslynEvaluator.TryReferenceAssemblyByNamespace(System.String,System.Boolean@)">
            <summary>
            References the assembly by the given namespace it implements.
            </summary>
            <param name="namespace">The namespace.</param>
            <param name="resolved">Set to <c>true</c> if the namespace was successfully resolved (found) and
            the reference was added; otherwise, <c>false</c>.</param>
            <returns>The instance of the <see cref="T:CSScriptLib.IEvaluator" /> to allow  fluent interface.</returns>
        </member>
        <member name="M:CSScriptLib.RoslynEvaluator.ReferenceAssemblyByNamespace(System.String)">
            <summary>
            References the assembly by the given namespace it implements.
            <para>Adds assembly reference if the namespace was successfully resolved (found) and, otherwise does nothing</para>
            </summary>
            <param name="namespace">The namespace.</param>
            <returns>The instance of the <see cref="T:CSScriptLib.IEvaluator" /> to allow  fluent interface.</returns>
        </member>
        <member name="M:CSScriptLib.RoslynEvaluator.ReferenceAssemblyOf(System.Object)">
            <summary>
            References the assembly by the object, which belongs to this assembly.
            <para>It is safe to call this method multiple times
            for the same assembly. If the assembly already referenced it will not
            be referenced again.
            </para>
            </summary>
            <param name="obj">The object, which belongs to the assembly to be referenced.</param>
            <returns>The instance of the <see cref="T:CSScriptLib.IEvaluator" /> to allow  fluent interface.</returns>
        </member>
        <member name="M:CSScriptLib.RoslynEvaluator.ReferenceAssemblyOf``1">
            <summary>
            References the assembly by the object, which belongs to this assembly.
            <para>It is safe to call this method multiple times
            for the same assembly. If the assembly already referenced it will not
            be referenced again.
            </para>
            </summary>
            <typeparam name="T">The type which is implemented in the assembly to be referenced.</typeparam>
            <returns>The instance of the <see cref="T:CSScriptLib.IEvaluator" /> to allow  fluent interface.</returns>
        </member>
        <member name="M:CSScriptLib.RoslynEvaluator.ReferenceDomainAssemblies(CSScriptLib.DomainAssemblies)">
            <summary>
            References the assemblies the are already loaded into the current <c>AppDomain</c>.
            </summary>
            <param name="assemblies">The type of assemblies to be referenced.</param>
            <returns>The instance of the <see cref="T:CSScriptLib.IEvaluator" /> to allow  fluent interface.</returns>
        </member>
        <member name="M:CSScriptLib.RoslynEvaluator.Reset(System.Boolean)">
            <summary>
            Resets Evaluator.
            <para>
            Resetting means clearing all referenced assemblies, recreating evaluation infrastructure (e.g. compiler setting)
            and reconnection to or recreation of the underlying compiling services.
            </para>
            <para>Optionally the default current AppDomain assemblies can be referenced automatically with
            <paramref name="referenceDomainAssemblies" />.</para>
            </summary>
            <param name="referenceDomainAssemblies">if set to <c>true</c> the default assemblies of the current AppDomain
            will be referenced (see <see cref="M:CSScriptLib.RoslynEvaluator.ReferenceDomainAssemblies(CSScriptLib.DomainAssemblies)" /> method).
            </param>
            <returns>The freshly initialized instance of the <see cref="T:CSScriptLib.IEvaluator" />.</returns>
        </member>
        <member name="T:CSScriptLib.MethodDelegate">
             <summary>
             Delegate which is used as a return type for AsmHelper.GetMethodInvoker().

             AsmHelper.GetStaticMethod() and AsmHelper.GetMethod() allow obtaining dynamic method delegate emitted on the base of the MethodInfo (from the compiled script type).
             </summary>
             <param name="paramters">Optional method parameters.</param>
             <returns>Returns MethodInfo return value</returns>
        </member>
        <member name="T:CSScriptLib.MethodDelegate`1">
             <summary>
             Delegate which is used as a return type for AsmHelper.GetMethodInvoker().

             AsmHelper.GetStaticMethod() and AsmHelper.GetMethod() allow obtaining dynamic method delegate emitted on the base of the MethodInfo (from the compiled script type).
             </summary>
             <typeparam name="T">The delegate return type.</typeparam>
             <param name="paramters">Optional method parameters.</param>
             <returns>Returns MethodInfo return value</returns>
        </member>
        <member name="T:CSScriptLib.DomainAssemblies">
            <summary>
            Type of the assemblies to be loaded/referenced.
            </summary>
        </member>
        <member name="F:CSScriptLib.DomainAssemblies.None">
            <summary>
            No assemblies
            </summary>
        </member>
        <member name="F:CSScriptLib.DomainAssemblies.AllStatic">
            <summary>
            All static current AppDomain assemblies
            </summary>
        </member>
        <member name="F:CSScriptLib.DomainAssemblies.AllStaticNonGAC">
            <summary>
            All static and non-GAC current AppDomain assemblies
            </summary>
        </member>
        <member name="F:CSScriptLib.DomainAssemblies.All">
            <summary>
            All current AppDomain assemblies
            </summary>
        </member>
        <member name="T:CSScriptLib.EvaluatorEngine">
            <summary>
            Type of the evaluator engine.
            <para>This enum is used to control type of compiler the generic
            CSScript.<see cref="P:CSScriptLib.CSScript.Evaluator" /> encapsulates.</para>
            </summary>
        </member>
        <member name="F:CSScriptLib.EvaluatorEngine.Roslyn">
            <summary>
            Roslyn compilation services
            </summary>
        </member>
        <member name="F:CSScriptLib.EvaluatorEngine.Mono">
            <summary>
            Mono compilation services
            </summary>
        </member>
        <member name="F:CSScriptLib.EvaluatorEngine.CodeDom">
            <summary>
            CodeDom compilation infrastructure
            </summary>
        </member>
        <member name="T:CSScriptLib.EvaluatorAccess">
            <summary>
            Runtime instantiation model for CS-Script evaluators (e.g CSScript.<see cref="P:CSScriptLib.CSScript.Evaluator" />).
            </summary>
        </member>
        <member name="F:CSScriptLib.EvaluatorAccess.Singleton">
            <summary>
            Every time the member variable is accessed the same static object is returned.
            </summary>
        </member>
        <member name="F:CSScriptLib.EvaluatorAccess.AlwaysCreate">
            <summary>
            Every time the member variable is accessed a new object is created.
            </summary>
        </member>
        <member name="T:CSScriptLib.EvaluatorConfig">
            <summary>
            Class that contains configuration options for controlling dynamic code evaluation with CSScript.<see cref="P:CSScriptLib.CSScript.Evaluator" />.
            </summary>
        </member>
        <member name="P:CSScriptLib.EvaluatorConfig.Access">
            <summary>
            Gets or sets the default access type for CS-Script evaluators.
               <para>This property controls the how the generic
            CS-Script evaluators are instantiated when accessed (e.g.
            CSScript.<see cref="P:CSScriptLib.CSScript.Evaluator" /> or ).
            </para>
            </summary>
            <value>The access.</value>
        </member>
        <member name="P:CSScriptLib.EvaluatorConfig.DebugBuild">
            <summary>
            Default value of the <see cref="T:CSScriptLib.IEvaluator" />.
            DebugBuild property controlling the generation of the debug symbols.
            <example>
            <code>
            CSScript.EvaluatorConfig.DebugBuild = true;
            dynamic script = CSScript.Evaluator
                                     .LoadMethod(...
            </code>
            </example>
            </summary>
        </member>
        <member name="P:CSScriptLib.EvaluatorConfig.RefernceDomainAsemblies">
            <summary>
            Flag that controls if the host AppDo,main referenced assemblies are automatically referenced at creation
            of <see cref="T:CSScriptLib.IEvaluator" />.
            </summary>
        </member>
        <member name="P:CSScriptLib.EvaluatorConfig.Engine">
            <summary>
            Gets or sets the default evaluator engine type.
            <para>This property controls the type of compiler the generic
            CSScript.<see cref="P:CSScriptLib.CSScript.Evaluator" /> encapsulates.</para>
            </summary>
            <value>The default evaluator engine.</value>
        </member>
        <member name="T:CSScriptLib.IEvaluator">
            <summary>
            A generic interface of the CS-Script evaluator. It encapsulates the generic functionality of the evaluator regardless
            of the nature of the underlying compiling services (e.g. Mono, Roslyn, CodeDom).
            </summary>
        </member>
        <member name="P:CSScriptLib.IEvaluator.DebugBuild">
            <summary>
            Gets or sets a value indicating whether to compile script with debug symbols.
            <para>Note, setting <c>DebugBuild</c> will only affect the current instance of Evaluator.
            If you want to emit debug symbols for all instances of Evaluator then use
            <see cref="P:CSScriptLib.CSScript.EvaluatorConfig" />.DebugBuild.
            </para>
            </summary>
            <value><c>true</c> if 'debug build'; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:CSScriptLib.IEvaluator.DisableReferencingFromCode">
            <summary>
            Gets or sets the flag indicating if the script code should be analyzed and the assemblies
            that the script depend on (via '//css_...' and 'using ...' directives) should be referenced.
            </summary>
            <value></value>
        </member>
        <member name="M:CSScriptLib.IEvaluator.CompileCode(System.String,CSScriptLib.CompileInfo)">
             <summary>
             Evaluates (compiles) C# code (script). The C# code is a typical C# code containing a single or multiple class definition(s).
             </summary>
             <example>
            <code>
             Assembly asm = CSScript.Evaluator
                                    .CompileCode(@"using System;
                                                   public class Script
                                                   {
                                                       public int Sum(int a, int b)
                                                       {
                                                           return a+b;
                                                       }
                                                   }");

             dynamic script =  asm.CreateObject("*");
             var result = script.Sum(7, 3);
             </code>
             </example>
             <param name="scriptText">The C# script text.</param>
             <param name="info">The information about compilation context (e.g. location of the compiler output -
             assembly and pdb file).</param>
             <returns>The compiled assembly.</returns>
        </member>
        <member name="M:CSScriptLib.IEvaluator.Check(System.String)">
             <summary>
             Compiles the specified script text without loading it into the AppDomain or
             writing to the file system.
             </summary>
             <example>
            <code>
             try
             {
                 CSScript.Evaluator
                         .Check(@"using System;
                                  public class Script
                                  {
                                      public int Sum(int a, int b)
                                      {
                                          error
                                          return a+b;
                                      }
                                  }");
             }
             catch (Exception e)
             {
                 Console.WriteLine("Compile error: " + e.Message);
             }
             </code>
             </example>
             <param name="scriptText">The script text.</param>
             <returns></returns>
        </member>
        <member name="M:CSScriptLib.IEvaluator.CompileAssemblyFromCode(System.String,System.String)">
             <summary>
             Compiles C# code (script) into assembly file. The C# code is a typical C# code containing a single or multiple class definition(s).
             </summary>
             <example>
            <code>
             string asmFile = CSScript.Evaluator
                                      .CompileAssemblyFromCode(
                                             @"using System;
                                               public class Script
                                               {
                                                   public int Sum(int a, int b)
                                                   {
                                                       return a+b;
                                                   }
                                               }",
                                               "MyScript.dll");
             </code>
             </example>
             <param name="scriptText">The C# script text.</param>
             <param name="outputFile">The path to the assembly file to be compiled.</param>
             <returns>The compiled assembly file path.</returns>
        </member>
        <member name="M:CSScriptLib.IEvaluator.CompileAssemblyFromFile(System.String,System.String)">
             <summary>
             Compiles C# file (script) into assembly file. The C# contains typical C# code containing a single or multiple class definition(s).
             </summary>
             <example>
            <code>
             string asmFile = CSScript.Evaluator
                                      .CompileAssemblyFromFile(
                                             "MyScript.cs",
                                             "MyScript.dll");
             </code>
             </example>
             <param name="scriptFile">The C# script file.</param>
             <param name="outputFile">The path to the assembly file to be compiled.</param>
             <returns>The compiled assembly file path.</returns>
        </member>
        <member name="M:CSScriptLib.IEvaluator.CompileMethod(System.String)">
             <summary>
             Wraps C# code fragment into auto-generated class (type name <c>DynamicClass</c>) and evaluates it.
             <para>
             This method is a logical equivalent of <see cref="M:CSScriptLib.IEvaluator.CompileCode(System.String,CSScriptLib.CompileInfo)" /> but is allows you to define
             your script class by specifying class method instead of whole class declaration.</para>
             </summary>
             <example>
            <code>
             dynamic script = CSScript.Evaluator
                                      .CompileMethod(@"int Sum(int a, int b)
                                                     {
                                                         return a+b;
                                                     }")
                                      .CreateObject("*");

             var result = script.Sum(7, 3);
             </code>
             </example>
             <param name="code">The C# code.</param>
             <returns>The compiled assembly.</returns>
        </member>
        <member name="M:CSScriptLib.IEvaluator.CreateDelegate(System.String)">
             <summary>
             Wraps C# code fragment into auto-generated class (type name <c>DynamicClass</c>), evaluates it and loads the class to the current AppDomain.
             <para>Returns non-typed <see cref="T:CSScriptLib.MethodDelegate" /> for class-less style of invoking.</para>
             </summary>
             <example>
             <code>
             var log = CSScript.Evaluator
                               .CreateDelegate(@"void Log(string message)
                                                 {
                                                     Console.WriteLine(message);
                                                 }");

             log("Test message");
             </code>
             </example>
             <param name="code">The C# code.</param>
             <returns> The instance of a 'duck typed' <see cref="T:CSScriptLib.MethodDelegate" /></returns>
        </member>
        <member name="M:CSScriptLib.IEvaluator.CreateDelegate``1(System.String)">
             <summary>
             Wraps C# code fragment into auto-generated class (type name <c>DynamicClass</c>), evaluates it and loads the class to the current AppDomain.
             <para>Returns typed <see cref="T:CSScriptLib.MethodDelegate`1" /> for class-less style of invoking.</para>
             </summary>
             <typeparam name="T">The delegate return type.</typeparam>
             <example>
             <code>
             var product = CSScript.Evaluator
                                   .CreateDelegate&lt;int&gt;(@"int Product(int a, int b)
                                                         {
                                                             return a * b;
                                                         }");

             int result = product(3, 2);
             </code>
             </example>
             <param name="code">The C# code.</param>
             <returns> The instance of a typed <see cref="T:CSScriptLib.MethodDelegate`1" /></returns>
        </member>
        <member name="M:CSScriptLib.IEvaluator.GetReferencedAssemblies(System.String,System.String[])">
            <summary>
            Analyses the script code and returns set of locations for the assemblies referenced from the code with CS-Script directives (//css_ref).
            </summary>
            <param name="code">The script code.</param>
            <param name="searchDirs">The assembly search/probing directories.</param>
            <returns>Array of the referenced assemblies</returns>
        </member>
        <member name="M:CSScriptLib.IEvaluator.GetReferencedAssemblies">
            <summary>
            Returns set of referenced assemblies.
            <para>
            Notre: the set of assemblies is cleared on Reset.
            </para>
            </summary>
            <returns></returns>
        </member>
        <member name="M:CSScriptLib.IEvaluator.LoadCode(System.String,System.Object[])">
             <summary>
             Evaluates and loads C# code to the current AppDomain. Returns instance of the first class defined in the code.
             </summary>
             <example>The following is the simple example of the LoadCode usage:
            <code>
             dynamic script = CSScript.Evaluator
                                      .LoadCode(@"using System;
                                                  public class Script
                                                  {
                                                      public int Sum(int a, int b)
                                                      {
                                                          return a+b;
                                                      }
                                                  }");
             int result = script.Sum(1, 2);
             </code>
             </example>
             <param name="scriptText">The C# script text.</param>
             <param name="args">The non default constructor arguments.</param>
             <returns>Instance of the class defined in the script.</returns>
        </member>
        <member name="M:CSScriptLib.IEvaluator.LoadCode``1(System.String,System.Object[])">
             <summary>
             Evaluates and loads C# code to the current AppDomain. Returns instance of the first class defined in the code.
             </summary>
             <example>The following is the simple example of the interface alignment:
            <code>
             public interface ICalc
             {
                 int Sum(int a, int b);
             }
             ....
             ICalc calc = CSScript.Evaluator
                                  .LoadCode&lt;ICalc&gt;(@"using System;
                                                     public class Script
                                                     {
                                                         public int Sum(int a, int b)
                                                         {
                                                             return a+b;
                                                         }
                                                     }");
             int result = calc.Sum(1, 2);
             </code>
             </example>
             <typeparam name="T">The type of the script class instance should be type casted to.</typeparam>
             <param name="scriptText">The C# script text.</param>
             <param name="args">The non default type <c>T</c> constructor arguments.</param>
             <returns>Aligned to the <c>T</c> interface instance of the class defined in the script.</returns>
        </member>
        <member name="M:CSScriptLib.IEvaluator.LoadDelegate``1(System.String)">
             <summary>
             Wraps C# code fragment into auto-generated class (type name <c>DynamicClass</c>), evaluates it and loads
             the class to the current AppDomain.
             <para>Returns instance of <c>T</c> delegate for the first method in the auto-generated class.</para>
             </summary>
              <example>
             <code>
             var Product = CSScript.Evaluator
                                   .LoadDelegate&lt;Func&lt;int, int, int&gt;&gt;(
                                               @"int Product(int a, int b)
                                                 {
                                                     return a * b;
                                                 }");

             int result = Product(3, 2);
             </code>
             </example>
             <param name="code">The C# code.</param>
             <returns>Instance of <c>T</c> delegate.</returns>
        </member>
        <member name="M:CSScriptLib.IEvaluator.LoadFile(System.String,System.Object[])">
             <summary>
             Evaluates and loads C# code from the specified file to the current AppDomain. Returns instance of the first
             class defined in the script file.
             </summary>
             <example>The following is the simple example of the interface alignment:
            <code>
             dynamic script = CSScript.Evaluator
                                      .LoadFile("calc.cs");

             int result = script.Sum(1, 2);
             </code>
             </example>
             <param name="scriptFile">The C# script file.</param>
             <param name="args">Optional non-default constructor arguments.</param>
             <returns>Instance of the class defined in the script file.</returns>
        </member>
        <member name="M:CSScriptLib.IEvaluator.LoadFile``1(System.String,System.Object[])">
             <summary>
             Evaluates and loads C# code from the specified file to the current AppDomain. Returns instance of the first
             class defined in the script file.
             After initializing the class instance it is aligned to the interface specified by the parameter <c>T</c>.
             <para><c>Note:</c> the script class does not have to inherit from the <c>T</c> parameter as the proxy type
             will be generated anyway.</para>
             </summary>
             <example>The following is the simple example of the interface alignment:
            <code>
             public interface ICalc
             {
                 int Sum(int a, int b);
             }
             ....
             ICalc calc = CSScript.Evaluator
                                  .LoadFile&lt;ICalc&gt;("calc.cs");

             int result = calc.Sum(1, 2);
             </code>
             </example>
             <typeparam name="T">The type of the interface type the script class instance should be aligned to.</typeparam>
             <param name="scriptFile">The C# script text.</param>
             <param name="args">Optional non-default constructor arguments.</param>
             <returns>Aligned to the <c>T</c> interface instance of the class defined in the script file.</returns>
        </member>
        <member name="M:CSScriptLib.IEvaluator.LoadMethod(System.String)">
             <summary>
             Wraps C# code fragment into auto-generated class (type name <c>DynamicClass</c>), evaluates it and loads
             the class to the current AppDomain.
             </summary>
             <example>The following is the simple example of the LoadMethod usage:
             <code>
             dynamic script = CSScript.Evaluator
                                      .LoadMethod(@"int Product(int a, int b)
                                                    {
                                                        return a * b;
                                                    }");

             int result = script.Product(3, 2);
             </code>
             </example>
             <param name="code">The C# script text.</param>
             <returns>Instance of the first class defined in the script.</returns>
        </member>
        <member name="M:CSScriptLib.IEvaluator.LoadMethod``1(System.String)">
            <summary>
            Wraps C# code fragment into auto-generated class (type name <c>DynamicClass</c>), evaluates it and loads
            the class to the current AppDomain.
            <para>
            After initializing the class instance it is aligned to the interface specified by the parameter <c>T</c>.
            </para>
            </summary>
            <example>The following is the simple example of the interface alignment:
            <code>
            public interface ICalc
            {
                int Sum(int a, int b);
                int Div(int a, int b);
            }
            ....
            ICalc script = CSScript.Evaluator
                                   .LoadMethod&lt;ICalc&gt;(@"public int Sum(int a, int b)
                                                        {
                                                            return a + b;
                                                        }
                                                        public int Div(int a, int b)
                                                        {
                                                            return a/b;
                                                        }");
            int result = script.Div(15, 3);
            </code>
            </example>
            <typeparam name="T">The type of the interface type the script class instance should be aligned to.</typeparam>
            <param name="code">The C# script text.</param>
            <returns>Aligned to the <c>T</c> interface instance of the auto-generated class defined in the script.</returns>
        </member>
        <member name="M:CSScriptLib.IEvaluator.ReferenceAssembliesFromCode(System.String,System.String[])">
            <summary>
            References the assemblies from the script code.
            <para>The method analyses and tries to resolve CS-Script directives (e.g. '//css_ref') and 'used' namespaces based on the
            optional search directories.</para>
            </summary>
            <param name="code">The script code.</param>
            <param name="searchDirs">The assembly search/probing directories.</param>
            <returns>The instance of the <see cref="T:CSScriptLib.IEvaluator" /> to allow  fluent interface.</returns>
        </member>
        <member name="M:CSScriptLib.IEvaluator.ReferenceAssembly(System.String)">
            <summary>
            References the given assembly by the assembly path.
            <para>It is safe to call this method multiple times for the same assembly. If the assembly already referenced it will not
            be referenced again.</para>
            </summary>
            <param name="assembly">The path to the assembly file.</param>
            <returns>The instance of the <see cref="T:CSScriptLib.IEvaluator" /> to allow  fluent interface.</returns>
        </member>
        <member name="M:CSScriptLib.IEvaluator.ReferenceAssembly(System.Reflection.Assembly)">
            <summary>
            References the given assembly.
            <para>It is safe to call this method multiple times
            for the same assembly. If the assembly already referenced it will not
            be referenced again.
            </para>
            </summary>
            <param name="assembly">The assembly instance.</param>
            <returns>The instance of the <see cref="T:CSScriptLib.IEvaluator" /> to allow  fluent interface.</returns>
        </member>
        <member name="M:CSScriptLib.IEvaluator.ReferenceAssemblyByName(System.String)">
            <summary>
            References the name of the assembly by its partial name.
            <para>Note that the referenced assembly will be loaded into the host AppDomain in order to resolve assembly partial name.</para>
            <para>It is an equivalent of <c>Evaluator.ReferenceAssembly(Assembly.LoadWithPartialName(assemblyPartialName))</c></para>
            </summary>
            <param name="assemblyPartialName">Partial name of the assembly.</param>
            <returns>The instance of the <see cref="T:CSScriptLib.IEvaluator" /> to allow  fluent interface.</returns>
        </member>
        <member name="M:CSScriptLib.IEvaluator.TryReferenceAssemblyByNamespace(System.String,System.Boolean@)">
            <summary>
            References the assembly by the given namespace it implements.
            </summary>
            <param name="namespace">The namespace.</param>
            <param name="resolved">Set to <c>true</c> if the namespace was successfully resolved (found) and
            the reference was added; otherwise, <c>false</c>.</param>
            <returns>The instance of the <see cref="T:CSScriptLib.IEvaluator" /> to allow  fluent interface.</returns>
        </member>
        <member name="M:CSScriptLib.IEvaluator.ReferenceAssemblyByNamespace(System.String)">
            <summary>
            References the assembly by the given namespace it implements.
            <para>Adds assembly reference if the namespace was successfully resolved (found) and, otherwise does nothing</para>
            </summary>
            <param name="namespace">The namespace.</param>
            <returns>The instance of the <see cref="T:CSScriptLib.IEvaluator" /> to allow  fluent interface.</returns>
        </member>
        <member name="M:CSScriptLib.IEvaluator.ReferenceAssemblyOf(System.Object)">
            <summary>
            References the assembly by the object, which belongs to this assembly.
            <para>It is safe to call this method multiple times
            for the same assembly. If the assembly already referenced it will not
            be referenced again.
            </para>
            </summary>
            <param name="obj">The object, which belongs to the assembly to be referenced.</param>
            <returns>The instance of the <see cref="T:CSScriptLib.IEvaluator" /> to allow  fluent interface.</returns>
        </member>
        <member name="M:CSScriptLib.IEvaluator.ReferenceAssemblyOf``1">
            <summary>
            References the assembly by the object, which belongs to this assembly.
            <para>It is safe to call this method multiple times
            for the same assembly. If the assembly already referenced it will not
            be referenced again.
            </para>
            </summary>
            <typeparam name="T">The type which is implemented in the assembly to be referenced.</typeparam>
            <returns>The instance of the <see cref="T:CSScriptLib.IEvaluator" /> to allow  fluent interface.</returns>
        </member>
        <member name="M:CSScriptLib.IEvaluator.ReferenceDomainAssemblies(CSScriptLib.DomainAssemblies)">
            <summary>
            References the assemblies the are already loaded into the current <c>AppDomain</c>.
            </summary>
            <param name="assemblies">The type of assemblies to be referenced.</param>
            <returns>The instance of the <see cref="T:CSScriptLib.IEvaluator" /> to allow  fluent interface.</returns>
        </member>
        <member name="M:CSScriptLib.IEvaluator.Reset(System.Boolean)">
            <summary>
            Resets Evaluator.
            <para>
            Resetting means clearing all referenced assemblies, recreating evaluation infrastructure (e.g. compiler setting)
            and reconnection to or recreation of the underlying compiling services.
            </para>
            <para>Optionally the default current AppDomain assemblies can be referenced automatically with
            <paramref name="referenceDomainAssemblies" />.</para>
            </summary>
            <param name="referenceDomainAssemblies">if set to <c>true</c> the default assemblies of the current AppDomain
            will be referenced (see <see cref="M:CSScriptLib.IEvaluator.ReferenceDomainAssemblies(CSScriptLib.DomainAssemblies)" /> method).
            </param>
            <returns>The freshly initialized instance of the <see cref="T:CSScriptLib.IEvaluator" />.</returns>
        </member>
        <member name="M:CSScriptLib.IEvaluator.Clone(System.Boolean)">
             <summary>
             Clones the parent <see cref="T:CSScriptLib.IEvaluator" />.
             <para>
             This method returns a freshly initialized copy of the <see cref="T:CSScriptLib.IEvaluator" />.
             The cloning 'depth' can be controlled by the <paramref name="copyRefAssemblies" />.
             </para>
             <para>
             This method is a convenient technique when multiple <see cref="T:CSScriptLib.IEvaluator" /> instances
             are required (e.g. for concurrent script evaluation).
             </para>
             </summary>
             <param name="copyRefAssemblies">if set to <c>true</c> all referenced assemblies from the parent <see cref="T:CSScriptLib.IEvaluator" />
             will be referenced in the cloned copy.</param>
             <returns>The freshly initialized instance of the <see cref="T:CSScriptLib.IEvaluator" />.</returns>
             <example>
            <code>
             var eval1 = CSScript.Evaluator.Clone();
             var eval2 = CSScript.Evaluator.Clone();

             var sub = eval1.LoadDelegate&lt;Func&lt;int, int, int&gt;&gt;(
                                        @"int Sub(int a, int b) {
                                              return a - b;
                                          }");

             var sum = eval2.LoadDelegate&lt;Func&lt;int, int, int&gt;&gt;(
                                        @"int Sub(int a, int b) {
                                              return a + b;
                                          }");

             var result = sum(7, sub(4,2));
             </code>
             </example>
        </member>
        <member name="T:CSScriptLib.ParsingParams">
            <summary>
            ParsingParams is a class that holds parsing parameters (parameters that controls how file is to be parsed).
            At this moment they are namespace renaming rules only.
            </summary>
        </member>
        <member name="M:CSScriptLib.ParsingParams.Compare(CSScriptLib.ParsingParams,CSScriptLib.ParsingParams)">
            <summary>
            Compare() is to be used to help with implementation of IComparer for sorting operations.
            </summary>
        </member>
        <member name="T:CSScriptLib.ScriptInfo">
            <summary>
            Class which is a placeholder for general information of the script file
            </summary>
        </member>
        <member name="M:CSScriptLib.ScriptInfo.#ctor(CSScriptLib.CSharpParser.ImportInfo)">
            <summary>
            Constructor
            </summary>
            <param name="info">ImportInfo object containing the information how the script file should be parsed.</param>
        </member>
        <member name="T:CSScriptLib.FileParser">
            <summary>
            Class that implements parsing the single C# script file
            </summary>
        </member>
        <member name="M:CSScriptLib.FileParser.ResolveFile(System.String,System.String[])">
            <summary>
            Searches for script file by given script name. Calls ResolveFile(string fileName, string[] extraDirs, bool throwOnError)
            with throwOnError flag set to true.
            </summary>
        </member>
        <member name="F:CSScriptLib.FileParser.ResolveFilesAlgorithm">
            <summary>
            The resolve file algorithm,
            <para>
            The default algorithm searches for script file by given script name. Search order:
            1. Current directory
            2. extraDirs (usually %CSSCRIPT_ROOT%\Lib and ExtraLibDirectory)
            3. PATH
            Also fixes file name if user did not provide extension for script file (assuming .cs extension)
            </para>
            </summary>
        </member>
        <member name="M:CSScriptLib.FileParser.ResolveFile(System.String,System.String[],System.Boolean)">
            <summary>
            Searches for script file by given script name. Search order:
            1. Current directory
            2. extraDirs (usually %CSSCRIPT_ROOT%\Lib and ExtraLibDirectory)
            3. PATH
            Also fixes file name if user did not provide extension for script file (assuming .cs extension)
            <para>If the default implementation isn't suitable then you can set <c>FileParser.ResolveFilesAlgorithm</c>
            to the alternative implementation of the probing algorithm.</para>
            </summary>
        </member>
        <member name="T:CSScriptLib.FileParserComparer">
             <summary>
             Class that implements parsing the single C# Script file
             </summary>
             <summary>
             Implementation of the IComparer for sorting operations of collections of FileParser instances
             </summary>
        </member>
        <member name="T:CSScriptLib.CoreExtensions">
             <summary>
             </summary>
        </member>
        <member name="M:CSScriptLib.CoreExtensions.SelectFirst(System.Xml.Linq.XContainer,System.String)">
            <summary>
            Selects the first element that satisfies the specified path.
            </summary>
            <param name="element">The element.</param>
            <param name="path">The path.</param>
            <returns></returns>
        </member>
        <member name="M:CSScriptLib.CoreExtensions.RemovePathDuplicates(System.String[])">
            <summary>
            Removes the duplicated file system path items from the collection.The duplicates are identified
            based on the path being case sensitive depending on the hosting OS file system.
            </summary>
            <param name="list">The list.</param>
            <returns></returns>
        </member>
        <member name="M:CSScriptLib.CoreExtensions.IsSharedAssembly(System.String)">
            <summary>
            Determines whether [is shared assembly].
            </summary>
            <param name="path">The path.</param>
            <returns>
              <c>true</c> if [is shared assembly] [the specified path]; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:CSScriptLib.CoreExtensions.ToBool(System.String)">
            <summary>
            Converts to bool.
            </summary>
            <param name="text">The text.</param>
            <returns></returns>
        </member>
        <member name="M:CSScriptLib.CoreExtensions.RemoveAssemblyExtension(System.String)">
            <summary>
            Removes the assembly extension.
            </summary>
            <param name="asmName">Name of the asm.</param>
            <returns></returns>
        </member>
        <member name="M:CSScriptLib.CoreExtensions.SamePathAs(System.String,System.String)">
            <summary>
            Compares two path strings. Handles path being case-sensitive based on the OS file system.
            </summary>
            <param name="path1">The path1.</param>
            <param name="path2">The path2.</param>
            <returns></returns>
        </member>
        <member name="M:CSScriptLib.CoreExtensions.CaptureExceptionDispatchInfo(System.Exception)">
            <summary>
            Captures the exception dispatch information.
            </summary>
            <param name="ex">The ex.</param>
            <returns></returns>
        </member>
        <member name="M:CSScriptLib.CoreExtensions.FileDelete(System.String,System.Boolean)">
            <summary>
            Files the delete.
            </summary>
            <param name="filePath">The file path.</param>
            <param name="rethrow">if set to <c>true</c> [rethrow].</param>
        </member>
        <member name="T:CSScriptLib.LinqExtensions">
            <summary>
            Various LINQ extensions
            </summary>
        </member>
        <member name="M:CSScriptLib.LinqExtensions.None``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})">
            <summary>
            None of the items matches the specified predicate.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="items">The items.</param>
            <param name="predicate">The predicate.</param>
            <returns></returns>
        </member>
        <member name="M:CSScriptLib.LinqExtensions.AddItem``1(System.Collections.Generic.IEnumerable{``0},``0)">
            <summary>
            Adds a single item to the collection.
            </summary>
            <typeparam name="TSource">The type of the source.</typeparam>
            <param name="items">The items.</param>
            <param name="item">The item.</param>
            <returns></returns>
        </member>
        <member name="M:CSScriptLib.LinqExtensions.IsEmpty``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Determines whether the collection is empty.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="collection">The collection.</param>
            <returns>
              <c>true</c> if the specified collection is empty; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:CSScriptLib.LinqExtensions.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})">
            <summary>
            A generic LINQ equivalent of C# foreach loop.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="collection">The collection.</param>
            <param name="action">The action.</param>
            <returns></returns>
        </member>
        <member name="T:CSScriptLib.PathExtensions">
            <summary>
            Various PATH extensions
            </summary>
        </member>
        <member name="T:CSScriptLib.ReflectionExtensions">
            <summary>
            Various Reflection extensions
            </summary>
        </member>
        <member name="M:CSScriptLib.ReflectionExtensions.Directory(System.Reflection.Assembly)">
            <summary>
            Returns directory where the specified assembly file is.
            </summary>
            <param name="asm">The asm.</param>
            <returns></returns>
        </member>
        <member name="M:CSScriptLib.ReflectionExtensions.Location(System.Reflection.Assembly)">
            <summary>
            Returns location of the specified assembly. Avoids throwing an exception in case
            of dynamic assembly.
            </summary>
            <param name="asm">The asm.</param>
            <returns></returns>
        </member>
        <member name="M:CSScriptLib.ReflectionExtensions.GetName(System.Type)">
            <summary>
            Gets the name of the type.
            </summary>
            <param name="type">The type.</param>
            <returns></returns>
        </member>
        <member name="M:CSScriptLib.ReflectionExtensions.CreateObject(System.Reflection.Assembly,System.String,System.Object[])">
            <summary>
            Creates instance of a class from underlying assembly.
            </summary>
            <param name="asm">The asm.</param>
            <param name="typeName">The 'Type' full name of the type to create. (see Assembly.CreateInstance()).
            You can use wild card meaning the first type found. However only full wild card "*" is supported.</param>
            <param name="args">The non default constructor arguments.</param>
            <returns>
            Instance of the 'Type'. Throws an ApplicationException if the instance cannot be created.
            </returns>
        </member>
        <member name="M:CSScriptLib.ReflectionExtensions.CreateInstance(System.Reflection.Assembly,System.String,System.Object[])">
            <summary>
            Creates instance of a Type from underlying assembly.
            </summary>
            <param name="asm">The asm.</param>
            <param name="typeName">Name of the type to be instantiated. Allows wild card character (e.g. *.MyClass can be used to instantiate MyNamespace.MyClass).</param>
            <param name="args">The non default constructor arguments.</param>
            <returns>
            Created instance of the type.
            </returns>
            <exception cref="T:System.Exception">Type " + typeName + " cannot be found.</exception>
        </member>
        <member name="M:CSScriptLib.ReflectionExtensions.IsDynamic(System.Reflection.Assembly)">
            <summary>
            Determines whether the assembly is dynamic.
            </summary>
            <param name="asm">The asm.</param>
            <returns>
              <c>true</c> if the specified asm is dynamic; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="T:CSScriptLib.Runtime">
            <summary>
            A class that hosts the most common properties of the runtime environment.
            </summary>
        </member>
        <member name="P:CSScriptLib.Runtime.NuGetCacheView">
            <summary>
            Gets the nuget cache path in the form displayable in Console.
            </summary>
            <value>
            The nu get cache view.
            </value>
        </member>
        <member name="P:CSScriptLib.Runtime.IsWin">
            <summary>
            Gets a value indicating whether the host OS Windows.
            </summary>
            <value>
              <c>true</c> if the host OS is Windows; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:CSScriptLib.Runtime.IsLinux">
            <summary>
            Note it is not about OS being exactly Linux but rather about OS having Linux type of file system.
            For example path being case sensitive
            </summary>
        </member>
        <member name="P:CSScriptLib.Runtime.IsMono">
            <summary>
            Gets a value indicating whether the runtime is Mono.
            </summary>
            <value>
              <c>true</c> if the runtime is Mono; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:CSScriptLib.Runtime.IsCore">
            <summary>
            Gets a value indicating whether the runtime is  core.
            </summary>
            <value>
              <c>true</c> if the runtime is  core; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:CSScriptLib.Runtime.IsNet">
            <summary>
            Gets a value indicating whether the runtime is .Net
            </summary>
            <value>
              <c>true</c> if the runtime is .Net; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:CSScriptLib.Runtime.DesktopAssembliesDir">
            <summary>
            Returns path to the `Microsoft.WindowsDesktop.App` shared assemblies of the compatible runtime version.
            <para>Note, there is no warranty that the dotnet dedktop assemblies belong to the same distro version as dotnet Core:
            <para> - C:\Program Files\dotnet\shared\Microsoft.NETCore.App\5.0.0-rc.1.20451.14</para>
            <para> - C:\Program Files\dotnet\shared\Microsoft.WindowsDesktop.App\5.0.0-rc.1.20452.2</para>
            </para>
            </summary>
        </member>
        <member name="T:CSScriptLib.StringExtensions">
            <summary>
            Various string extensions
            </summary>
        </member>
        <member name="M:CSScriptLib.StringExtensions.IsEmpty(System.String)">
            <summary>
            Determines whether the string is empty (or null).
            </summary>
            <param name="text">The text.</param>
            <returns>
              <c>true</c> if the specified text is empty; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:CSScriptLib.StringExtensions.IsNotEmpty(System.String)">
            <summary>
            Determines whether the string is not empty (or null).
            </summary>
            <param name="text">The text.</param>
            <returns>
              <c>true</c> if [is not empty] [the specified text]; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:CSScriptLib.StringExtensions.TrimSingle(System.String,System.Char[])">
            <summary>
            Trims a single character form the head and the end of the string.
            </summary>
            <param name="text">The text.</param>
            <param name="trimChars">The trim chars.</param>
            <returns></returns>
        </member>
        <member name="M:CSScriptLib.StringExtensions.SameAs(System.String,System.String,System.Boolean)">
            <summary>
            Compares two strings.
            </summary>
            <param name="text">The text.</param>
            <param name="pattern">The pattern.</param>
            <param name="ignoreCase">if set to <c>true</c> [ignore case].</param>
            <returns></returns>
        </member>
        <member name="M:CSScriptLib.StringExtensions.IsOneOf(System.String,System.String[])">
            <summary>
            Checks if the given string matches any of the provided patterns.
            </summary>
            <param name="text">The text.</param>
            <param name="patterns">The patterns</param>
            <returns></returns>
        </member>
        <member name="M:CSScriptLib.StringExtensions.JoinBy(System.Collections.Generic.IEnumerable{System.String},System.String)">
            <summary>
            Joins strings the by the specified separator.
            </summary>
            <param name="values">The values.</param>
            <param name="separator">The separator.</param>
            <returns></returns>
        </member>
        <member name="M:CSScriptLib.WildCardExtensions.GetMatchingDirs(System.String,System.String)">
            <summary>
            Gets the directories specified by either relative or absolute path `rootDir`.
            `rootDir` can contain wild-cards as per Git 'ignore specification'
            </summary>
            <param name="baseDir">The working dir.</param>
            <param name="rootDir">The root dir path as per Git 'ignore specification'.</param>
            <returns></returns>
        </member>
        <member name="T:csscript.ResolveSourceFileAlgorithm">
            <summary>
            Delegate implementing source file probing algorithm.
            </summary>
            <param name="file">The file.</param>
            <param name="searchDirs">The extra dirs.</param>
            <param name="throwOnError">if set to <c>true</c> [throw on error].</param>
            <returns></returns>
        </member>
        <member name="T:csscript.ResolveAssemblyHandler">
            <summary>
            Delegate implementing assembly file probing algorithm.
            </summary>
            <param name="file">The file.</param>
            <param name="searchDirs">The extra dirs.</param>
            <returns></returns>
        </member>
        <member name="T:csscript.AssemblyResolver">
            <summary>
            Utility class for assembly probing.
            </summary>
        </member>
        <member name="F:csscript.AssemblyResolver.ignoreFileName">
            <summary>
            File to be excluded from assembly search
            </summary>
        </member>
        <member name="M:csscript.AssemblyResolver.IsLegalPathToken(System.String)">
            <summary>
            Determines whether the string is a legal path token.
            </summary>
            <param name="name">The name.</param>
            <returns>
            	<c>true</c> if the string is a legal path token; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:csscript.AssemblyResolver.FindAssembly(System.String,System.String[])">
            <summary>
            Resolves namespace/assembly(file) name into array of assembly locations (local and GAC ones).
            </summary>
            <param name="name">'namespace'/assembly(file) name</param>
            <param name="searchDirs">Assembly search directories</param>
            <para>If the default implementation isn't suitable then you can set <c>CSScript.FindAssemblyAlgorithm</c>
            to the alternative implementation of the probing algorithm.</para>
            <returns>collection of assembly file names where namespace is implemented</returns>
        </member>
        <member name="M:csscript.AssemblyResolver.FindLocalAssembly(System.String,System.String)">
            <summary>
            Resolves namespace into array of local assembly locations.
            (Currently it returns only one assembly location but in future
            it can be extended to collect all assemblies with the same namespace)
            </summary>
            <param name="name">namespace/assembly name</param>
            <param name="dir">directory</param>
            <returns>collection of assembly file names where namespace is implemented</returns>
        </member>
        <member name="M:csscript.AssemblyResolver.FindGlobalAssembly(System.String)">
            <summary>
            Resolves namespace into array of global assembly (GAC) locations.
            <para>NOTE: this method does nothing on .NET Core as it offers no GAC discovery mechanism.</para>
            </summary>
            <param name="namespaceStr">'namespace' name</param>
            <returns>collection of assembly file names where namespace is implemented</returns>
        </member>
    </members>
</doc>